# 理解 Amateras 原型树（Proto Tree）
什么是原型（Proto）？原型是一个节点，它能对应具体的 DOM 元素，或者是一个模块节点。一个原型能够包含多个子原型，往上追溯到没有父原型的就是根原型（Root Proto）。这些原型互相连接能够组成一个原型树。

原型的作用之一是保存模板的构建函数，这些原型在被创建时并不会直接运行构建函数，而是要等到执行构建方法 `Proto.build()` 后才会开始进行模板的构建。我把从模板转换到 DOM 的流程分为三个主要步骤：

1. 创建原型（Craft）
2. 构建模板（Build）
3. 将原型树渲染成 DOM 或 HTML String（Render）

## 创建原型
当我们执行创建函数 `$` 时，就是一次创建原型的行为。

下面是一个创建元素原型（Element Proto）的代码，`$` 函数分别接收到三个参数：标签名，元素属性，模板函数。

```ts
$('h1', { class: 'title' },  () => $`Hello World!`)
```

原型被创建，但不会有 DOM 被生成，模板函数（Template Function）也不会执行，因此这个原型也不会有子原型。

> [!WARNING]
> 由于插件模块能够拦截创建函数的创建过程，理论上能够透过这个方式直接执行构建函数，但这并不符合标准的模块规范。

## 构建模板
当原型执行构建方法 `build()` 之后，附属于该原型的子原型都会被创建，随后再对所有子原型执行构建方法，直到最后一个原型被构建完成。

```ts
const $section = $('div', () => {
    $('h1', () => $`Hello World!`)
    $`This is a message from Amateras.`
})

$section.build();
```

上例是一个创建原型和构建原型的代码，让我们来一步一步分析整个过程：

1. 我们创建了一个 `div` 为标签名的元素原型，并且将包含其子原型内容的模板函数一同传递进去。
2. 调用构建方法 `build()`。
3. `div` 模板函数执行。
   1. 模板内第一个元素原型 `h1` 被创建，并添加到 `div` 原型的子原型列表中。
   2. 模板内第二个文本原型 `This is a message from Amateras.` 被创建，并添加到 `div` 原型的子原型列表中。
4. `div` 模板函数执行完毕，开始对每个子原型执行构建方法 `build()`。
   1. `h1` 模板函数执行。
      1. 模板内第一个文本原型 `Hello World!` 被创建后添加到子原型列表。
   2. `h1` 模板函数执行完毕，开始对每个子原型执行构建方法 `build()`。
      1. `Hello World` 是文本原型，没有模板函数。
   3. `h1` 构建结束。
   4. `This is a message from Amateras.` 是文本原型，没有模板函数。
5. `div` 构建结束。

### 先创建，再构建
从上面的步骤解析中，原型构建时会把所有模板函数内的原型先创建好，之后才会开始构建每一个子原型。上一层级的原型都创建之后才开始创建下一层级的原型，这是原型系统非常重要的概念之一。

### 构建一次
构建方法理论上只需要执行一次，后续原型树的变化将会交由模块自行处理。如果你执行了两次构建，那么前一次构建的原型树将会被移除并释放内存，新构建好的原型树将会代替。

## 渲染 DOM/HTML
将原型构建好后，只差一步就能将 DOM 树生成。使用渲染方法 `toDOM()` 或者 `toString()` 就能获取完整的 DOM 树或者 HTML 文本。

```ts
const $title = $('h1', { class: 'title' }, () => $`Hello World!`);
$title.build(); // 构建原型树
$title.toDOM(); // 返回 [HTMLHeadingElement]
$title.toString(); // 返回 <h1 class="title">Hello World!</h1>
```

> [!NOTE]
> 渲染和构建是完全分开的，并且只要构建一次后，无论渲染多少次都不会改变原型树。