# 组件数据仓库（Widget Store）
在实际开发场景中，开发者不可避免需要让一些关联的组件之间共享数据，这个时候能够绑定组件的数据以及能让子组件获取自己的数据的组件数据仓库就能帮助到你。

## 为什么不使用全局变量？
我们可以在一个文件中定义一个变量并导出，所有需要读取该变量的文件都能直接导入引用。这是一个非常优雅的方法，但很可惜在大多数情况下我们不希望这么做：

### 组件复用造成数据冲突
有些组件被设计成需要被多次复用，比如名片组件、自定义按键组件等，这些组件各自都可能需要一个属于自己的独立数据仓库以进行更复杂的交互，我们不希望其它同类型的组件会对这个组件的数据进行改动。

### 管理复数个同型组件的数据状态
我们当然可以为每个组件都设定一个哈希表，我们将哈希表的键值设为父组件，子组件需要访问这个父组件的数据时再使用父组件去获取就好。但是……如果这个父组件并不在上一层，而是相隔十几层呢？每次都要写找寻父组件的逻辑代码吗……听起来有点麻烦？

### 地狱式嵌套传递数据
或者我们让该组件以及其子组件能够使用特定的识别名找到正确的数据，我们只需要将这个识别名在每次创建时都一一传入到组件属性中，即使是要传递几十层……听起来有点地狱。

正因为如此，我们为开发者简化了这一流程，避免了地狱式嵌套传递数据的问题。


## 使用方式

```ts
// 定义父组件
const App = $.widget(() => ({
    store: { 
        count$: $.signal(0)
    },
    builder({store}) {
        $('p', () => $`Count is ${store.count$}`)
        $(AddCountButton, {increase: 2})
    }
}))

// 定义子组件
const AddCountButton = $.widget(
    (props: {increase: number}) => ({
        ancestors: [App],
        builder({store, children}) {
            $('button', $$ => { $`Add ${props.increase}`
                $$.on('click', () => {
                    // 可读写来自父级组件 App 的数据
                    store.count$.set(val => val + props.increase)
                });
            })
            children();
        }
    })
);

$.render($(App), () => document.body)

// 输出：<p>Count is 0</p><button>Add 2</button>
```

## 函数拆解

```ts
type 组件初始化函数 = {
    ancestors?: 父级组件数组,
    store?: 组件数据仓库,
    builder: 组件模板函数
}
```
#### 父级组件构造器数组
如果我们将多个组件构造器传入这个数组中，组件函数会将其视为这个组件的父级组件。不论这些组件和子组件相隔多少层级，子组件都能顺利访问到这些父级组件的数据。

#### 组件数据仓库
这是个在组件初始化时会建立的数据仓库，即使同样的组件被创建多次，各个同组件的数据仓库都不互通各自独立。但是我们能够透过组件函数将此组件构造器作为子组件的父级数据仓库，只有该组件的子组件才能够访问到自己的数据仓库。

#### 组件模板函数
组件模板函数的第一个参数包含了两个属性：`store` 和 `children`。`store` 属性能够访问该组件以及父级组件的数据仓库。
```ts
type 组件模板函数 =
    ($$: {
        store: 组件数据仓库
        children: 子模版函数
    }) => void
```

## 相关文档
1. [组件](/docs/Widget.md)